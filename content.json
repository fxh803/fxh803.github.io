{"meta":{"title":"fxh的博客","subtitle":"","description":"","author":"fxh","url":"https://fxhblog.com","root":"/"},"pages":[{"title":"关于","date":"2023-12-03T10:27:34.358Z","updated":"2023-12-03T10:27:34.358Z","comments":false,"path":"about/index.html","permalink":"https://fxhblog.com/about/index.html","excerpt":"","text":"1234567891011121314151617&#123; &quot;name&quot;: &quot;fxh&quot;, &quot;age&quot;: 23, &quot;gender&quot;: &quot;男&quot;， &quot;address&quot;: &quot;广东省深圳市&quot;, &quot;education&quot;: &quot;硕士在读&quot;， &quot;github&quot;: &quot;https://github.com/fxh803&quot;, &quot;email&quot;: &quot;2210904816@qq.com&quot;, &quot;skills&quot;:[ [&quot;python&quot;,&quot;c++&quot;], [&quot;html&quot;,&quot;css&quot;,&quot;javascript&quot;], [&quot;bootstrap&quot;,&quot;jquery&quot;,&quot;echarts&quot;], [&quot;flask&quot;,&quot;mongodb&quot;] ]&#125;"},{"title":"标签","date":"2023-09-05T09:12:09.708Z","updated":"2023-01-09T13:30:40.000Z","comments":false,"path":"tags/index.html","permalink":"https://fxhblog.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-09-05T09:12:09.660Z","updated":"2023-01-09T13:30:40.000Z","comments":false,"path":"categories/index.html","permalink":"https://fxhblog.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-09-05T09:12:09.676Z","updated":"2023-01-09T13:30:40.000Z","comments":true,"path":"links/index.html","permalink":"https://fxhblog.com/links/index.html","excerpt":"","text":""},{"title":"项目","date":"2023-09-05T09:12:09.693Z","updated":"2023-01-09T17:47:56.000Z","comments":false,"path":"repository/index.html","permalink":"https://fxhblog.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"unity的URP渲染管线","slug":"unity的URP渲染管线","date":"2023-12-05T16:00:00.000Z","updated":"2023-12-06T13:35:48.399Z","comments":true,"path":"2023/12/06/unity的URP渲染管线/","link":"","permalink":"https://fxhblog.com/2023/12/06/unity%E7%9A%84URP%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/","excerpt":"","text":"什么是URP渲染管线，它有什么优点URP全称universal rendering pipeline。在unity中是一种渲染流程，与默认的build-in渲染管线不一样，它有很多优点。1.多平台，URP可以在不同的平台上保持一致的效果。2.高性能，相较于默认管线，性能更好。3.模块化，允许开发者更容易地定制和扩展渲染管线。作为入门我这个还没有感觉到。4.现代渲染特性，先较默认管线多出来很多渲染功能，如后处理，屏幕空间反射等等。 怎么转换到URP渲染管线如图所示，点击窗口，包管理器，选择unity注册表。然后搜索universal xxxx，就弹出这个，下载。接下来新建一个URP配置文件，如图所示。创建之后会有两个文件，然后我们打开项目设置的graphic选项，如图把配置文件拖过去。然后我们发现一些材质变成了紫色，那是因为适用于原本管线的材质在URP中失效了，我们需要把它们转换成URP的材质。 URP材质转换在2022版unity中，点击窗口，渲染，我们看到有一个渲染管线转换器，点击它。我们把所有选项都勾选，然后点击initialize and convert。 如果转换之后还是出现紫色，说明这些材质可能要自己手动去调整为URP材质。以这个树枝为例。我们要找到universal rendering pipeline的着色器，选择lit。对于这个树枝的材质调整，首先是把先前的贴图贴上，然后是选择alpha裁剪，设置一定的数，让材质像树丛一样有缝隙。然后表面材质选择不透明，使场景有树荫。其他可以看情况去调整。 重新渲染为了获得更好的光影，我们重新将场景的光影渲染全部去除并重新添加 天空盒和直接光在窗口，渲染选项中找到照明，然后在环境选项卡中添加默认天空盒，同时在场景中添加直接光。在直接光选项中添加软阴影环境选项卡中添加直接光为太阳光源，以及添加天空盒为环境照明和环境反射。其他属性看情况调整一下。 场景烘焙在这里我们首先要新建一个光照设置。烘焙的设置比较多，首先分为实时光照和混合照明。 实时光照实时光照很明显，就是计算机实时计算你的光。它会将你场景的所有灯光设置成实时模式，所有静态和非静态的物体表面光照都会受实时光照影响。 混合照明混合照明比较复杂，分三种模式：间接烘焙（BakedIndirect），shadowmask ，减性（Subtractive） BakedIndirect在此模式下Baked和Mixed模式灯光只会渲染间接光源（物体反弹的光）我把所有光源都去掉了，树林还有间接光 SubtractiveMixed的灯光对静态物体烘培直接光源间接光源和阴影，对动态物体实时渲染阴影，删掉的话会影响动态对象的阴影渲染Baked的灯光对静态物体烘培直接光源间接光源和阴影，不对动态物体实时渲染光线，删掉的话不影响场景 这是mixed光，对于动态物体（树）是实时渲染的，而对于静态物体（地面）则是烘焙（光照不变）。把mixed光去除，发现地面因为渲染了直接光比较亮，而动态物体（树）就变暗了，而且没有了阴影。换成baked光，动态物体（树）不实时渲染了。而且去不去除这个灯光对树和地面都没有影响。 shadowmaskShadownmask类似 BakedIndirect，不同的就是渲染阴影的方式。Shadowmask 光照模式允许 Unity 在运行时结合烘焙阴影和实时阴影，并允许渲染远处的阴影。并且提供最好的阴影渲染效果简而言之就是近处阴影是实时远处是烘焙阴影 在这个场景，我们渲染一下间接光照。 反射探针反射探针可以实现一些镜面反射的效果。如上图新建一个发射探测器。如果没有在场景烘焙那里选择自动生成，就要每次改动都点击一下发射探测器的bake按钮，我们可以在场景烘焙那里勾选一下自动生成。调整探针区域，覆盖住这个场景把探针本身放到合适的位置，实现反射 后处理后处理的功能十分强大，这里举两个例子 bloom 泛光添加一个全局体积新建一个配置文件，然后添加覆盖bloom。稍微拉一下数值，得到一个暖色调的泛光，模拟日落。 tone mapping添加覆盖tone mapping，设置模式为ACES获得较强的对比度 环境光遮挡从项目设置的graphic选项卡中点击管道设置找到相应资产再点击这个资产的渲染器找到对应的渲染器添加下图中的光遮挡选项，设置一定的强度 获得细节处的光遮挡阴影，通常这个效果是应用于物体拐角缝隙处，呈现阴影的效果。","categories":[{"name":"unity","slug":"unity","permalink":"https://fxhblog.com/categories/unity/"}],"tags":[]},{"title":"谷歌OWL-ViT模型","slug":"谷歌OWL-ViT模型","date":"2023-12-02T16:00:00.000Z","updated":"2023-12-07T11:36:40.166Z","comments":true,"path":"2023/12/03/谷歌OWL-ViT模型/","link":"","permalink":"https://fxhblog.com/2023/12/03/%E8%B0%B7%E6%AD%8COWL-ViT%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"这是什么模型？OWL-ViT是一个开放词汇物体检测模型，给予查询文本query_text或者查询图片，模型可以在目标图像target_image上检测目标。 大致结构此项工作首先是通过图像文本对去预训练一个图像和文本编码器（左图）类似于CLIP，然后再将预训练的两个编码器放到开放词汇检测模型中（右图），但是去掉了token pooling，添加了linear projection和MLP head两个模块连接到输出。然后再进行find-tuning去优化其余的部分网络。 推理过程 输入输出图中展示了模型是如何进行推理的。我们可以看到模型的输入是文本+图片，输出是预测框（predicted boxes）和对应输出框的类别（predicted classes/queries）。 文本编码成向量对于文本，是经过了一个text Transformer encoder的编码，应该是跟transformer的encoder差不多的结构，将文本转换成向量作为query embeddings。图中三个类别就是三个向量，如图紫色方块。 图片编码成向量对于图片，是经过 vision transformer的编码器转成向量，就是图中四个粉色的矩形，然后通过线性投影和多层感知机将向量转换到合适的维度上。对于他们的数量，如图有4个patch，就有4个image_imbeddings，4个pred_boxes, 就是图中绿色和白色的矩形。他们之间是一一对应的，代表着检测的一个一个box。而在我使用的模型中，输入图片尺寸是768768，patch 尺寸是3232，因此会有（768768）/（3232）=576个image_imbeddings和pred_boxes。即最大可以有576个盒子。 计算余弦相似度类似CLIP模型，将得到的query embeddings（紫色方块的向量）和线性投影后的向量（绿色方块的向量）进行点乘，点乘的结果越大说明越相似。 举个栗子 在结构图中的点乘矩阵，第一行最大的数在第一列，说明第一行最有可能是giraffe，所以相应的box（x1，y1，w1，h1）就被预测为giraffe长颈鹿。第三行的第二列最大，所以box（x3，y3，w3，h3）被预测为tree。而第四行的每个点乘结果都很低，经过阈值筛选后没有得到结果（no object）。 图像文本编码器的预训练在大致结构中，我们得知要先预训练两个编码器。首先我们先了解两个编码器的构造。 Text Transformer encoder这里的文本编码器应该就是普通的transformer编码器1.将文本单词text2seq之后的向量跟位置向量相加2.进入多头注意力机制3.把多头注意力的结果和position embedded的输入向量相加并归一化4.进入Feed Forward 层，这是一个两层的全连接层，第一层的激活函数为 Relu，第二层不使用激活函数5.跟第3步相似，也是把进入Feed Forward 层前的向量和Feed Forward 层后的向量相加并归一化。6.重复N次，得到结果 Vision Transformer encoder上图就是vision transformer的分类任务的流程。首先先将一张图片分割成许多个patch，如图所示这里分成了9个。然后将每一个patch图片拍平变成一维的向量通过线性投射层。举个栗子，patch可以是16x16，那么每个patch维度就是16x16x3=768，然后有9个patch，就是9x768 ，经过线性投影也还是 9x768 ，但是还有特殊字符cls，因此最终的维度是10x768 然后我们需要将patch向量和位置向量相加，不是拼接，维度不变。 然后我们就把这个维度为10x768的向量丢进这个transformer Encoder： 1，首先是将这个向量进行归一化（NORM）,然后进入多头自注意力机制中。2，然后将多头子注意力机制的结果与encoder原输入相加，进行归一化，再经过多层感知机得到结果。3，然后又将多层感知机的结果跟上一次相加后的向量相加，输出。4，这个过程重复L次。 从encoder出来之后进入多层感知机，便进行分类。 self attention上面提及自注意力机制，这里阐述一下过程 如上图所示，在这里我们的x1，x2就是我们归一化之后的且positon embedded的patches。通过与Wq，Wk和Wv进行矩阵运算之后得到q，k，v。Wq，Wk和Wv 这三个矩阵是我们要训练的东西。我们有10个x，x1~x10。 单个q与所有的k进行点乘，得到score 然后我们要将得到的score除以一个数，这个数一般是x矩阵的第一个维度的开方，就是patch数量的开方，我们这应该是根号10。然后将运算后的结果放到softmax中。然后把softmax的结果和v相乘。得到v1，v2，v3，v4…v10，再将他们全部加起来得到z1。 最后以此类推，计算出z2，z3，z4… z10，拼接起来得到单个self attention的结果。这个过程可以通过矩阵运算快速得到。如果是多头自注意力，就是将多个子注意力输出的z向量拼接，然后经过线性变化得到结果。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://fxhblog.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"基于react-native框架的移动端开发","slug":"基于react-native框架的移动端开发","date":"2023-09-05T16:00:00.000Z","updated":"2023-12-03T10:04:51.983Z","comments":true,"path":"2023/09/06/基于react-native框架的移动端开发/","link":"","permalink":"https://fxhblog.com/2023/09/06/%E5%9F%BA%E4%BA%8Ereact-native%E6%A1%86%E6%9E%B6%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/","excerpt":"","text":"什么是react-native（RN）?rn其实可以看作react框架在移动端的一个“兄弟”框架，它的写法跟react差不多。使用rn好处在于即使对Android原生开发不熟悉，但有写web的经验的话很快能够上手。 环境配置参考官方环境配置指引 这里不详细展开，总体而言我们需要配置node.js , jdk(Java SE Development Kit) 和 android studio。 node.js建议通过nvm安装管理node，nvm可以随时切换node版本，不用担心不同项目的node版本不同而无法运行只能重新卸载安装node。 android studio在下载androidstudio通常需要使用梯子，感觉使用美国节点下载可能更快更稳定一些（未经验证）。在这里有一些小坑，比如说Intel x86 Atom_64 System Image这个模拟器镜像我在SDK Manager的 SDK Platforms里半天找不到，后来选了个下图最相似的这个东东，后面模拟器能跑，就当且如此吧。 项目运行前配置在运行之前，要了解到构建一个rn项目需要一些时间去下载相关内容。因此我们要保证有一个良好的网络环境，以及考虑下载缓存对c盘的挤占。因此我配置了一下下载文件的路径，使其将缓存下到我希望的文件夹位置。 更改Android studio默认构建文件路径构建时androidstudio会在C:\\Users\\xxx（你的用户名）文件夹生成.gradle文件夹。这个文件夹大几G非常吃空间，因此我们需要在合适的地方创建文件夹，让它下载构建到此处。这里我示范新路径D:\\AndroidStudioData\\.gradle 配置环境变量的系统变量 更改Android studio默认模拟器文件路径如果你在androidstudio中创建模拟器或直接在项目运行时创建模拟器，会在C:\\Users\\xxx（你的用户名）文件夹生成.android文件夹，这个文件夹也是巨大无比高达10G以上。这里我示范新路径D:\\AndroidStudioData\\.android 配置环境变量的系统变量 项目的运行 RN?启动!我们可以在合适位置新建一个项目 123npx react-native@latest init AwesomeProject # 新建项目cd AwesomeProject # 进入项目文件夹yarn android #前提是你已安装yarn 如果是第一次运行新项目，建议别着急yarn android，不然会很慢才能启动。慢就算了，而且有可能卡在一个地方不显示正在运行的脚本信息（其实它在构建只是没告诉你）。这样的问题是如果网络不好构建的很慢你无从知晓，眼看这终端卡住一点东西都弹不出来急死人。 因此我们在androidstudio中打开项目文件夹中的android文件夹，让它预先构建好。androidstudio的右下方可以显示构建的详细信息。 看到右下方不再构建，我们就可以 1yarn android 记得提前用USB连接你的手机或者打开一个模拟器。 项目构造1234567App.js/App.tsx #项目的根组件index.js #项目入口app.json #项目的配置文件android #安卓的项目数据文件夹ios #ios的项目数据文件夹node_modules #包文件夹package.json #包信息json文件 rn语法入门看这个名叫HomeScreen的组件文件 其实如果比较了解web三件套可以很明显的看出rn的代码其实也只是三件套的另一种组织方式。 123456789101112131415import xxx #导入包const HomeScreen=()=&gt;&#123; ... const f=()=&gt;&#123;&#125; #一个函数f ... return&#123; ... #html &#125;&#125; #一个HomeScreen组件 const styles= StyleSheet.create(&#123; ...&#125;); #一个CSS的样式表export default HomeScreen;#导出组件 有时候也可以有这样的一种形式： 123456789import xxx #导入包export default function a =()=&gt;&#123; ... const f=()=&gt;&#123;&#125; #一个函数f ... return&#123; ... #html &#125;&#125; #一个组件a 结语关于rn还有很多细枝末节还没有摸清楚，但想要编写一个移动端应用，掌握好基本的rn使用其实就已经ok了。","categories":[{"name":"移动端开发","slug":"移动端开发","permalink":"https://fxhblog.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"https://fxhblog.com/tags/react-native/"},{"name":"android","slug":"android","permalink":"https://fxhblog.com/tags/android/"}]},{"title":"flask项目部署到阿里云","slug":"flask项目部署到阿里云","date":"2023-01-29T09:18:04.000Z","updated":"2023-12-03T10:07:55.782Z","comments":true,"path":"2023/01/29/flask项目部署到阿里云/","link":"","permalink":"https://fxhblog.com/2023/01/29/flask%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91/","excerpt":"","text":"前言上一年在学校做好了一个前后端打通的web应用，但是只是在本地上运行，没有部署到服务器。之前也没有接触过相关知识，于是跟着教程尝试部署了一下。 购买服务器这里就略过，我选择的是阿里云云服务器ECS上Ubuntu16 64位的系统。购买完之后会有一个实例，就是我们购买好的服务器，然后第一步我们就要重置实例密码（ssh链接密码），作为接下来我们连接服务器的密码。 添加安全组添加5000端口，添加80端口，5000是我们flask的端口，80是nginx的端口，所以都要设置好。如图： ssh链接服务器打开我们的cmd/powershell，输入： 1ssh root@xx.xx.xx.xx #如：ssh root@23.187.187.12（你刚刚买的服务器的公网ip） 然后输入我们刚刚更改的实例密码，就进入到了我们的服务器。输入密码的时候不会显示字符。 更新apt源1sudo apt-get update #把源更新一下，保证我们用的包都是最新可兼容的 安装mongodb1、安装1sudo apt-get install mongodb # apt-get 安装 mongodb 安装好后我们验证一下，如果安装不成功，就百度一下报错，大多可能是版本问题 1234# 默认下载完后自动启动，可以用以下命令进行验证service mongodb status # 查看mongodb的启动状态#或者mongo #进入mongodb数据库验证 2、配置验证好之后，我们要对mongodb进行配置 12# 修改配置vim /etc/mongodb.conf vim命令可以进入到服务器的文件进行修改，这里有几个常用的vim操作 进入编辑模式：在键盘上按下字母i或者a 退出编辑模式： 方式一：按下esc键，输入“:wq”3个英文字符，然后按下Enter键，表示保存文件并退出。 方式二：按下esc键，输入“:q”两个英文字符，然后按下Enter键，表示不保存并退出。（如果本次编辑没有修改内容，则可以顺利退出；否则，vim编辑器是不会允许你退出的，这时如果想要不保存退出，就要使用下面的方法三） 方式三：按下esc键，输入“:q!”3个英文字符，然后按Enter键，表示不保存并强制退出。 参考:vim操作 于是我们进入到文件之后按下a/i，把文件中的配置信息改成如下（注意有的配置项已存在，直接更改不要全部复制粘贴）： 123456789101112131415161718... ...#dbpath=/home/ctr_temp/data_base_temp/mongodb/datadbpath=/var/lib/mongodb#where to log#logpath=/home/ctr_temp/data_base_temp/mongodb/log/mongodb.loglogpath=/var/log/mongodb/mongodb.loglogappend=true# bind_ip = 127.0.0.1bind_ip = 0.0.0.0 #允许外网访问port = 27017# Enable journaling, http://www.mongodb.org/display/DOCS/Journalingjournal=true... ... 参考：mongo配置 然后稍微重启一下mongodb 123service mongodb stop #stopservice mongodb start #startservice mongodb status # 查看mongodb的启动状态 3、设置用户信息这一步其实可以不做数据库就已经可以使用，但不做的话MongoDB只允许本地连接，同时不需要使用任何账号密码就可以直接连接MongoDB。所以还是要稍微配置一下。 首先进入数据库，首次没有配置安全认证的情况下进入无需使用用户名以及密码验证 12345mongo&gt; show dbs # 查看当前已有的数据库admin 0.000GBconfig 0.000GBlocal 0.000GB 创建管理员用户 1234&gt; use admin #进入admin这个库switched to db admin&gt; db.createUser(&#123;user:&quot;xxx_xxxx&quot;,pwd:&quot;xxxxxxxx&quot;,roles:[&#123;role:&quot;root&quot;, db:&quot;admin&quot;&#125;]&#125;) #user和password可以自定义Successfully added user... 这个管理员是可以掌控整个mongodb的，暂时我们先创建这一个root管理员。有需要的话我们还可以创建多个用户，以实现不同的权限功能，如： 123456&gt; use admin&gt; db.createUser(&#123;user:&quot;xxx_xxxx&quot;,pwd:&quot;xxxxxxxx&quot;,roles: [&#123;role:&quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot;&#125;]&#125;)#授予在所有数据库上管理User的权限&gt; use test_db #新建一个数据库&gt; db.createUser(&#123;user:&quot;db_owner&quot;, pwd:&quot;xxxxxxxx&quot;, roles:[&#123;role:&quot;dbOwner&quot;, db:&quot;test_db&quot;&#125;]&#125;)#在当前DB中执行任意操作&gt; db.createUser(&#123;user:&quot;db_user&quot;, pwd:&quot;xxxxxxxx&quot;, roles:[&#123;role:&quot;readWrite&quot;, db:&quot;test_db&quot;&#125;]&#125;)#授予User读写数据的权限 具体mongodb可以创建的用户类型（role）大概有这几种： 数据库用户角色（Database User Roles） read：授予User只读数据的权限 readWrite：授予User读写数据的权限 数据库管理角色（Database Administration Roles）： dbAdmin：在当前dB中执行管理操作 dbOwner：在当前DB中执行任意操作 userAdmin：在当前DB中管理User 备份和还原角色（Backup and Restoration Roles）： backup restore 跨库角色（All-Database Roles）： readAnyDatabase：授予在所有数据库上读取数据的权限 readWriteAnyDatabase：授予在所有数据库上读写数据的权限 userAdminAnyDatabase：授予在所有数据库上管理User的权限 dbAdminAnyDatabase：授予管理所有数据库的权限 集群管理角色（Cluster Administration Roles）： clusterAdmin：授予管理集群的最高权限 clusterManager：授予管理和监控集群的权限，A user with this role can access the config and local databases, which are used in sharding and replication, respectively. clusterMonitor：授予监控集群的权限，对监控工具具有readonly的权限 hostManager：管理Server 创建完后我们可以验证一下是否创建成功： 123456789101112131415&gt; use adminswitched to db admin&gt; show users&#123; &quot;_id&quot; : &quot;admin.xxx_xxxx&quot;, &quot;userId&quot; : UUID(&quot;xxxxxxxxxxxxxxxxxxxx&quot;), &quot;user&quot; : &quot;xxx_xxxx&quot;, &quot;db&quot; : &quot;admin&quot;, &quot;roles&quot; : [ &#123; &quot;role&quot; : &quot;root&quot;, &quot;db&quot; : &quot;admin&quot; &#125; ]&#125; 4、启用用户认证1vim /etc/mongodb.conf #进入文件进行配置 将auth项的值置为true 1234567891011... ...# Enables periodic logging of CPU utilization and I/O wait#cpu = true# Turn on/off security. Off is currently the default#noauth = trueauth = true# Verbose logging output.#verbose = true... ... 重启一下数据库 123&gt; exit #退出mongobyeservice mongodb restart #重启 5、测试我们直接不用账户登录，会显示没有权限 123456789mongo&gt; show dbs2022-08-27T14:50:30.755+0800 E QUERY [thread1] Error: listDatabases failed:&#123; &quot;ok&quot; : 0, &quot;errmsg&quot; : &quot;there are no users authenticated&quot;, &quot;code&quot; : 13, &quot;codeName&quot; : &quot;Unauthorized&quot;&#125; :... ... 用我们的管理员账户登录试试看 1mongo -u xxxxxx -p xxxxxxxx --authenticationDatabase admin # xxxx为你的用户名和密码 123456789101112131415161718192021222324252627mongo -u xxx_xxxx -p xxxxxxxx --authenticationDatabase admin MongoDB shell version v3.6.8connecting to: mongodb://127.0.0.1:27017Implicit session: session &#123; &quot;id&quot; : UUID(&quot;xxxxxxxxxxxxxxxxxxxxx&quot;) &#125;MongoDB server version: 3.6.8Server has startup warnings:... ...&gt; show dbs #查看系统各个数据库情况admin 0.000GBconfig 0.000GBlocal 0.000GB# 如果没有向一个数据库填入任何信息的话，默认不显示&gt; use admin #查看一个库switched to db admin&gt; show users #查看用户&#123; &quot;_id&quot; : &quot;admin.xxx_xxxx&quot;, &quot;userId&quot; : UUID(&quot;xxxxxxxxxxxxxxxxx&quot;), &quot;user&quot; : &quot;xxx_xxxx&quot;, &quot;db&quot; : &quot;admin&quot;, &quot;roles&quot; : [ &#123; &quot;role&quot; : &quot;root&quot;, &quot;db&quot; : &quot;admin&quot; &#125; ]&#125; 至此mongo数据库就搞定了 虚拟环境1、安装虚拟环境在~/目录下（链接到服务器的最开始目录）创建.virtualenvs文件夹 1mkdir .virtualenvs 下载pip包 12pip install virtualenvpip install virtualenvwrapper 配置环境变量 1vim ~/.bashrc 将如下代码添加到文件的最后 1234567# 指定虚拟环境目录export WORKON_HOME=$HOME/.virtualenvs# 指定python版本export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3# 指定virtualenv的路径export VIRTUALENVWRAPPER_VIRTUALENV=/usr/local/bin/virtualenvsource /usr/local/bin/virtualenvwrapper.sh 激活设置 1source ~/.bashrc 2、创建虚拟环境我们每一个项目最好都有一个独立的虚拟环境，以保证我们的整个系统不会因为杂乱的各种环境设置搞得乱七八糟 在python3中，创建虚拟环境 1mkvirtualenv -p python3 虚拟环境名称 #如：mkvirtualenv -p python3 venv（一个叫venv的虚拟环境） 3、进入虚拟环境1workon 对应虚拟环境名 #workon venv 如果不知道虚拟环境名，可以输完workon 点击两下tab键既可以提示你的虚拟环境名 安装配置Nginx1、安装在我们刚刚建好的虚拟环境下安装nginx 1sudo apt-get install nginx 我们要知道的nginx的启动停止指令(先别输入) 12/etc/init.d/nginx start #启动/etc/init.d/nginx stop #停止 2、配置1vim /etc/nginx/sites-available/default 进入上述文件后改成如下配置(不要直接复制，有一些配置项只是注释了，我们要看好每一项进行配置)： 123456789101112131415161718192021222324252627# 如果是多台服务器的话，则在此配置，并修改 location 节点下面的 proxy_pass upstream flask &#123; server 127.0.0.1:5000; server 127.0.0.1:5001;&#125;server &#123; # 监听80端口 listen 80 default_server; listen [::]:80 default_server; root /var/www/html; index index.html index.htm index.nginx-debian.html; server_name _; location / &#123; # 请求转发到gunicorn服务器 proxy_pass http://127.0.0.1:5000; # 请求转发到多个gunicorn服务器 # proxy_pass http://flask; # 设置请求头，并将头信息传递给服务器端 proxy_set_header Host $host; # 设置请求头，传递原始请求ip给 gunicorn 服务器 proxy_set_header X-Real-IP $remote_addr; &#125;&#125; 3、测试1/etc/init.d/nginx start #启动nginx 打开浏览器，网址栏输入你的公网地址，可以看到以下界面，或者是一个 welcome to nginx 的界面 安装gunicorn在虚拟环境下安装gunicorn 1pip install gunicorn 还没安装flask的也要安装 12pip list #查询已安装的包pip install flask 测试一下，新建一个py文件 1vim test.py #新建 1234567891011#文件内容from flask import Flask app = Flask(__name__)@app.route(&#x27;/&#x27;)def index(): return &quot;只因你太美&quot; if __name__ == &quot;__main__&quot;: app.run() 运行test.py文件，在文件所在目录下运行一下命令： 12345#gunicorn 语法格式如下# -w: 表示进程（worker） -b：表示绑定ip地址和端口号（bind）#gunicorn -w 2 -b 127.0.0.1:5000 运行文件名称:Flask程序实例名gunicorn -w 2 -b 127.0.0.1:5000 test:app 打开浏览器，刷新网页，就可以看到我们期待已久的鸡哥了 项目上传1、导出环境把在本地用到的包导出到一个requirements.txt的文件 1pip freeze &gt; requirements.txt 导出之后放在项目文件夹中等会一起上传到服务器 2、项目上传至github本人是将项目上传到github再转到服务器上，然后我们要用到git这个代码管理工具，所以要先下载git，再在GitHub上创建一个仓库，然后通过git把项目上传到GitHub仓库再转存到服务器上。 上传到github可参考这篇文章 3、服务器拉取GitHub项目12sudo apt-get install git #安装gitgit clone https://github.com/xxxxx/xxxxx.git #把项目复制到服务器 4、安装所需pip包12cd 你的仓库名 #进入项目文件夹pip install -r requirements.txt #安装pip包 项目运行项目运行前要确保项目已经更改为生产下的代码，而非本地调试开发运行的代码。如前端请求函数的ip地址端口要设置好为服务器的ip地址，连接mongodb时要加上数据库用户名和密码获得权限等，具体问题不会就度娘== 123#启动应用gunicorn -w 2 -b 0.0.0.0:5000 xxx:app #0.0.0.0监听发送到本服务器的请求gunicorn -w 2 -b 0.0.0.0:5000 xxx:app -D #后台运行，关闭链接服务器将继续运行flask应用 如果要结束运行，则杀死flask进程 12netstat -tulpn #查看系统网络进程kill -9 xxxxx #杀死xxxx号进程 至此我们的项目就跑起来了！","categories":[{"name":"服务器部署","slug":"服务器部署","permalink":"https://fxhblog.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"flask","slug":"flask","permalink":"https://fxhblog.com/tags/flask/"},{"name":"mongodb","slug":"mongodb","permalink":"https://fxhblog.com/tags/mongodb/"},{"name":"python","slug":"python","permalink":"https://fxhblog.com/tags/python/"},{"name":"linux","slug":"linux","permalink":"https://fxhblog.com/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://fxhblog.com/tags/ubuntu/"},{"name":"nginx","slug":"nginx","permalink":"https://fxhblog.com/tags/nginx/"}]},{"title":"博客搭建","slug":"博客搭建","date":"2023-01-08T16:00:00.000Z","updated":"2023-12-03T10:03:01.939Z","comments":true,"path":"2023/01/09/博客搭建/","link":"","permalink":"https://fxhblog.com/2023/01/09/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"跟随教程: csdn我是如何搭建我的博客的？github page通过 github page+hexo实现的个人博客搭建，github page可以托管我们的静态网页，适合博客这种比较简单无后端的网站，还有一个优点是免费。一开始我是打算通过阿里云实现一个服务，但是发现要收费，学生党没钱就此作罢。于是我把目光投向GitHub page，提供一个免费的服务器，也免去了自己搭建服务器和写数据库的麻烦。 hexohexo是一个博客框架，依赖node.js。免去了对前端页面html，css等的复杂编写，把博客搭建简化了许多，也让人可以专注于博客内容本身而非其他。 开始搭建1 安装node.js我们的hexo框架需要依赖node.js，所以我们先安装node.js。选择recommended for most users版本即可 什么是node.js:node.js我的理解就是一个让JavaScript能够在服务器端运行的运行环境，把我们常接触的在浏览器前端的js变成一个在后端也能进行服务的语言。 2 安装git我们需要通过git来把我们写好的文件上传到github上托管，于是安装git安装完成后通过cmd/powershell输入 1git --version 若显示以下版本信息 1git version xx.xx.xx.windows.xx 说明安装成功,此时在任意一个文件夹右键会有一个 Git bash here 的按钮，通过这个可以用命令行对这个文件夹进行git的管理 3 安装hexo我们在合适的位置新建一个文件夹，作为我们的博客文件夹，然后在这个文件夹中右键点击 git bash here，输入以下npm命令即可安装。 1npm install hexo-cli -g # 安装hexo 若显示以下信息 12+ hexo-cli@x.x.xupdated 1 package in xx s 即安装成功 什么是npm：Node.js 平台的默认包管理工具，类似python的pip，conda 4 初始化hexo在刚刚新建的文件夹里新建一个名为Hexo的文件夹，在这个Hexo文件夹内右键，点击git bash here，输入以下命令 1hexo init 然后显示 12added xxx packages in xxx sINFO start blogging with hexo! 即完成hexo初始化 然后我们可以继续输入 12hexo g # g即generate生成，生成静态文件hexo s # s即server服务，打开本地调试服务 1INFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. # 此时hexo在本地localhost:4000上运行 在浏览器打开http://localhost:4000，就可以看到hexo默认主题下的hello world 示例到此，我们的博客在本地上已经可以运行，接下来我们要部署到github上 5 github pages准备工作首先注册github 注册好之后，我们点击右上角的小头像，找到your repositories，点开后找到一个绿色的new按钮，新建一个GitHub库存，用来放我们的博客文件 6 配置SSH密钥SSH密钥?：Git使用https协议，每次pull, push都要输入密码，相当的烦。使用git协议，然后使用SSH密钥。这样可以省去每次都输密码。大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。配置好 SSH 密钥后，我们才可以通过 git 操作实现本地代码库与 Github 代码库同步 在你的博客文件夹（hexo文件夹的上一级文件夹）git bash here输入以下命令: 1ssh-keygen -t rsa -C &quot;邮箱地址&quot; # 引号里面填写你的邮箱地址，比如我的是2210904816@qq.com 之后会出现： 12Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/xxx/.ssh/id_rsa): # 到这里可以直接回车将密钥按默认文件进行存储 然后： 12Enter passphrase (empty for no passphrase): # 这里是要你输入密码，其实不需要输什么密码，直接回车就行 Enter same passphrase again: # 再回车一次 接下来屏幕会显示： 1234Your identification has been saved in /c/Users/xxx/.ssh/id_rsa. Your public key has been saved in /c/Users/xxx/.ssh/id_rsa.pub. The key fingerprint is: # 这里是各种字母数字组成的字符串，结尾是你的邮箱 The key&#x27;s randomart image is: # 这里也是各种字母数字符号组成的字符串 运行以下指令，把公钥复制到粘贴板上： 1clip &lt; ~/.ssh/id_rsa.pub 7 在github添加你的公钥登录github，点击右上角头像，进入settings，找到左侧栏SSH and GPG keys new一个ssh keys 然后添加，title随便写，key复制粘贴板上刚刚复制的密钥 8 测试ssh在博客文件夹git bash here 复制以下指令： 1ssh -T git@github.com # 原封不动地复制过去即可 然后如下显示： 马上填yes 然后显示： 1Hi xxx! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 说明成功 9 配置 Git 个人信息Git 会根据用户的名字和邮箱来记录提交，GitHub 也是用这些信息来做权限的处理，输入以下命令进行个人信息的设置，把名称和邮箱替换成你自己的，名字可以不是 GitHub 的昵称，但为了方便记忆，建议与 GitHub 一致 12git config --global user.name &quot;此处填你的用户名&quot; # 如git config --global user.name &quot;fxh803&quot;git config --global user.email &quot;此处填你的邮箱&quot; # 如git config --global user.email &quot;2210xxxxxx@qq.com&quot; 到此为止 SSH Key 配置成功，本机已成功连接到 Github 10 将本地的 Hexo 文件更新到 Github 的库中登录 Github 打开自己的项目：用户名.github.io 鼠标移到右上绿色的按钮，选择SSH 点击复制，然后进入hexo文件夹里，右键用记事本（Notepad++或者VS code等都可以）打开该文件夹下的 _config.yml 文件 按如下修改：(冒号后面有个空格) 然后在hexo文件夹输入以下指令： 1npm install hexo-deployer-git --save # 安装hexo部署到GitHub的包 123hexo g #generate生成文件hexo d #deploy部署文件到远程# 或者 hexo g -d 然后就部署完成了你的博客地址：https://你的用户名.github.io，现在每个人都可以通过此链接访问你的博客了 更换主题在官方主题网站有很多主题可供我们选择，这里以我自己的主题为例点击这些主题页面，通常我们都可以找到主题作者的github，然后在他们的仓库里找到我们想要的那个主题仓库(通常命名为hexo-theme-xxx)，复制网址 然后打开我们hexo文件夹下的themes文件夹，右键git bash here，输入指令： 1git clone https://... # 我们刚刚复制的主题网址 下载完之后，我们要在hexo文件夹下的 _config.yml 文件找到关键字 theme，修改参数为：theme：hexo-theme-xxx （就是你刚刚复制的主题仓库的名称） 返回 Hexo 目录，右键 Git Bash Here ，输入以下命令开始部署主题： 12hexo ghexo s 在本地localhost:4000检查我们的主题是否更换，完成后我们就可以上传到github pages： 123hexo ghexo d# hexo g -d 此时访问自己的博客即可看见更换后的主题，但我们仍然需要对主题的相关配置进行修改，比如网站标题，图标等等，Hexo 中有两份主要的配置文件，名称都是 _config.yml ，它们均是用于站点配置使用的。其中，一份位于站点根目录下（比如：d:\\xxx\\Hexo\\ _config.yml），主要包含 Hexo 本身整站的配置；另一份位于主题目录下（比如：d:\\xxx\\Hexo\\themes\\hexo-theme-pure\\ _config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项，一般 _config.yml 文件里都有相关注释，按需修改即可 发表文章我们在博客文件夹的hexo/source/_posts里新建一个xxx.md的文件，或者在hexo文件夹输入 1hexo new xxx 即可新建一个md文件，然后在这个文件里编写我们的博客内容，具体md(markdown)语法自行百度，这里有一个例子： 1234567891011121314151617---title: 文章名称date: 文章日期photos: 文章封面图（仅部分主题支持）tags: - 文章标签1 - 文章标签2 - 文章标签3categories: 文章分类---### 标题1...### 标题2... 我们可以先打开本地服务边写边看网页效果： 1hexo s 写完之后我们可以用以下指令上传： 123hexo ghexo d# hexo g -d 配置域名xxx.github.io这个域名真的太捞了，马上去阿里云搞个域名 注册登录阿里云，找到他们的热门产品域名注册-&gt;查询自己想要的域名-&gt;加入清单-&gt;支付-&gt;填写个人信息模板-&gt;完成 然后回到首页，点击右上角控制台-&gt;我的导航找到最近使用点击域名-&gt;点击左侧域名列表-&gt;点击我们要的域名列点击解析 点击添加记录，需要添加两个记录，两个记录类型都是 CNAME ，第一个主机记录为 @ ，第二个主机记录为 www，记录值都是填你自己的博客地址（比如我的是：fxh803.github.io），保存之后域名解析就完成了！（主机记录有 @ 和 www 能保证URL加不加 www 都能访问） 为了使 GitHub 接收我们的域名，还需要在博客的根目录下添加一个名为 CNAME 的文件（注意不要加.txt，没有任何后缀名！），这个文件放到 Hexo 文件夹的 source 里面，文件里面填写你的域名（加不加www都行），比如要填写我的域名，文件里面就写：www.fxhblog.com 或者 fxhblog.com，经过以上操作，别人就可以通过 www.fxhblog.com 、fxhblog.com、fxh803.github.io 三个当中任意一个访问博客了这里我一开始填 www.fxhblog.com 会访问不了出bug，建议还是填xxx.com，简短点也好","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://fxhblog.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://fxhblog.com/tags/hexo/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://fxhblog.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"github page","slug":"github-page","permalink":"https://fxhblog.com/tags/github-page/"},{"name":"git","slug":"git","permalink":"https://fxhblog.com/tags/git/"},{"name":"node.js","slug":"node-js","permalink":"https://fxhblog.com/tags/node-js/"}]}],"categories":[{"name":"unity","slug":"unity","permalink":"https://fxhblog.com/categories/unity/"},{"name":"深度学习","slug":"深度学习","permalink":"https://fxhblog.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"移动端开发","slug":"移动端开发","permalink":"https://fxhblog.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"服务器部署","slug":"服务器部署","permalink":"https://fxhblog.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"},{"name":"个人博客","slug":"个人博客","permalink":"https://fxhblog.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"https://fxhblog.com/tags/react-native/"},{"name":"android","slug":"android","permalink":"https://fxhblog.com/tags/android/"},{"name":"flask","slug":"flask","permalink":"https://fxhblog.com/tags/flask/"},{"name":"mongodb","slug":"mongodb","permalink":"https://fxhblog.com/tags/mongodb/"},{"name":"python","slug":"python","permalink":"https://fxhblog.com/tags/python/"},{"name":"linux","slug":"linux","permalink":"https://fxhblog.com/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://fxhblog.com/tags/ubuntu/"},{"name":"nginx","slug":"nginx","permalink":"https://fxhblog.com/tags/nginx/"},{"name":"hexo","slug":"hexo","permalink":"https://fxhblog.com/tags/hexo/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://fxhblog.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"github page","slug":"github-page","permalink":"https://fxhblog.com/tags/github-page/"},{"name":"git","slug":"git","permalink":"https://fxhblog.com/tags/git/"},{"name":"node.js","slug":"node-js","permalink":"https://fxhblog.com/tags/node-js/"}]}